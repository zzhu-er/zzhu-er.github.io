<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Next.js中的Web渲染策略-CSR, SSR, SSG, ISR（一） | ZZHU-ER’s Tech Road</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Next.js中的Web渲染策略-CSR, SSR, SSG, ISR（一）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Intro 最近在学习前端，接触到了Next.js以及Web渲染的四种策略，CSR，SSR，SSG，以及ISR。 首先简单解释一些术语： SPA（Single-Page Application）： 单页应用。用新数据动态重写当前页面，而非加载整个页面，避免频繁的页面切换。比如我们常见的Gmail，Twitter，Discord等等都是典型的SPA。 CSR（Client-Side Rendering）： 客户端渲染。直接在浏览器中使用JavaScript渲染页面。逻辑，数据，路由等几乎所有工作都在客户端处理。 SSR（Server-Side Rendering）： 服务器端渲染。在服务器端进行渲染，将渲染好的HTML页面发送至浏览器或客户端。 SSG（Static-Site Generation）： 静态站点生成，同样在服务器端渲染，但是只在构建（build）时生成一次。数据只有在下次构建（rebuild）时才会更新。 ISR（Incremental Static Generation）： 增量式静态生成。在SSG的基础上，支持更新静态页面，而不必重新构建整个网站。" />
<meta property="og:description" content="Intro 最近在学习前端，接触到了Next.js以及Web渲染的四种策略，CSR，SSR，SSG，以及ISR。 首先简单解释一些术语： SPA（Single-Page Application）： 单页应用。用新数据动态重写当前页面，而非加载整个页面，避免频繁的页面切换。比如我们常见的Gmail，Twitter，Discord等等都是典型的SPA。 CSR（Client-Side Rendering）： 客户端渲染。直接在浏览器中使用JavaScript渲染页面。逻辑，数据，路由等几乎所有工作都在客户端处理。 SSR（Server-Side Rendering）： 服务器端渲染。在服务器端进行渲染，将渲染好的HTML页面发送至浏览器或客户端。 SSG（Static-Site Generation）： 静态站点生成，同样在服务器端渲染，但是只在构建（build）时生成一次。数据只有在下次构建（rebuild）时才会更新。 ISR（Incremental Static Generation）： 增量式静态生成。在SSG的基础上，支持更新静态页面，而不必重新构建整个网站。" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2023/04/24/web-rendering-strategies.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2023/04/24/web-rendering-strategies.html" />
<meta property="og:site_name" content="ZZHU-ER’s Tech Road" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-24T00:53:08+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Next.js中的Web渲染策略-CSR, SSR, SSG, ISR（一）" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-24T00:53:08+08:00","datePublished":"2023-04-24T00:53:08+08:00","description":"Intro 最近在学习前端，接触到了Next.js以及Web渲染的四种策略，CSR，SSR，SSG，以及ISR。 首先简单解释一些术语： SPA（Single-Page Application）： 单页应用。用新数据动态重写当前页面，而非加载整个页面，避免频繁的页面切换。比如我们常见的Gmail，Twitter，Discord等等都是典型的SPA。 CSR（Client-Side Rendering）： 客户端渲染。直接在浏览器中使用JavaScript渲染页面。逻辑，数据，路由等几乎所有工作都在客户端处理。 SSR（Server-Side Rendering）： 服务器端渲染。在服务器端进行渲染，将渲染好的HTML页面发送至浏览器或客户端。 SSG（Static-Site Generation）： 静态站点生成，同样在服务器端渲染，但是只在构建（build）时生成一次。数据只有在下次构建（rebuild）时才会更新。 ISR（Incremental Static Generation）： 增量式静态生成。在SSG的基础上，支持更新静态页面，而不必重新构建整个网站。","headline":"Next.js中的Web渲染策略-CSR, SSR, SSG, ISR（一）","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2023/04/24/web-rendering-strategies.html"},"url":"http://localhost:4000/jekyll/update/2023/04/24/web-rendering-strategies.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="ZZHU-ER&apos;s Tech Road" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">ZZHU-ER&#39;s Tech Road</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Next.js中的Web渲染策略-CSR, SSR, SSG, ISR（一）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-04-24T00:53:08+08:00" itemprop="datePublished">Apr 24, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="intro">Intro</h2>
<p>最近在学习前端，接触到了Next.js以及Web渲染的四种策略，CSR，SSR，SSG，以及ISR。
首先简单解释一些术语：<br />
<strong>SPA</strong>（Single-Page Application）：<br />
单页应用。用新数据动态重写当前页面，而非加载整个页面，避免频繁的页面切换。比如我们常见的Gmail，Twitter，Discord等等都是典型的SPA。<br />
<strong>CSR</strong>（Client-Side Rendering）：<br />
客户端渲染。直接在浏览器中使用JavaScript渲染页面。逻辑，数据，路由等几乎所有工作都在客户端处理。<br />
<strong>SSR</strong>（Server-Side Rendering）：<br />
服务器端渲染。在服务器端进行渲染，将渲染好的HTML页面发送至浏览器或客户端。<br />
<strong>SSG</strong>（Static-Site Generation）：<br />
静态站点生成，同样在服务器端渲染，但是只在构建（build）时生成一次。数据只有在下次构建（rebuild）时才会更新。<br />
<strong>ISR</strong>（Incremental Static Generation）：<br />
增量式静态生成。在SSG的基础上，支持更新静态页面，而不必重新构建整个网站。</p>

<h2 id="csr">CSR</h2>
<p>CSR是我们使用React构建SPA时的默认方式。在Next.js中，我们有两种方式实现CSR。</p>
<ul>
  <li>使用useEffect():<br />
就像在纯粹的React中一样，我们在Next.js中可以使用useEffect hook。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">time</span><span class="p">,</span> <span class="nx">setTime</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isLoading</span><span class="p">,</span> <span class="nx">setLoading</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setLoading</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://worldtimeapi.org/api/ip</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setTime</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">datetime</span><span class="p">)</span>
      <span class="nx">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">},</span> <span class="p">[])</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">time</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>使用SWR（Highly Recommend）：<br />
SWR是Next.js团队创建的一个用于数据请求的轻量级React hook库。它提供了很多有用的特性，具体可以参考<a href="https://swr.vercel.app/">官方文档</a>。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">swr</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">fetcher</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">fetch</span><span class="p">(...</span><span class="nx">args</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span><span class="nx">data</span><span class="p">,</span> <span class="nx">error</span><span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://worldtimeapi.org/api/ip</span><span class="dl">'</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>Failed to load<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">datetime</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ssr">SSR</h2>
<p>作为Next.js的主要卖点之一，SSR在Next.js中是通过在<a href="https://nextjs.org/docs/basic-features/pages">page</a>（其实就是一个component）中导出一个<code class="language-plaintext highlighter-rouge">getServerSideProps</code>函数实现的。当我们请求时，Next.js会使用该函数返回的数据在服务器端预渲染当前页面，最后将渲染好的页面返回给浏览器。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">({</span><span class="nx">data</span><span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">datetime</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// This gets called on every request</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getServerSideProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Fetch data from external API</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://worldtimeapi.org/api/ip</span><span class="dl">'</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="c1">// Pass data to the page via props</span>
  <span class="k">return</span> <span class="p">{</span><span class="na">props</span><span class="p">:</span> <span class="p">{</span><span class="nx">data</span><span class="p">}}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ssg">SSG</h2>
<p>默认情况下，Next.js总是会试图在构建时（build）静态生成页面，如果该页面是被写死的（hard-coded）。在这种情况下，我们不需要任何额外操作。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello,World.<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>但是，如果我们页面上的一些内容来自于外部资源（例如headless CMS），那么我们需要使用<code class="language-plaintext highlighter-rouge">getStaticProps</code>函数帮助我们从外部请求数据。这样，在页面被静态创建时，该函数返回的数据会被填充在页面中。并且，像SSR一样，<code class="language-plaintext highlighter-rouge">getStaticProps</code>函数只能被从一个页面中导出。将它放在其他任何地方都不会起作用。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">({</span><span class="nx">data</span><span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">datetime</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// This gets called at build time on server-side</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://worldtimeapi.org/api/ip</span><span class="dl">'</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="k">return</span> <span class="p">{</span><span class="na">props</span><span class="p">:</span> <span class="p">{</span><span class="nx">data</span><span class="p">}}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在某些情况下，我们可能有多个页面，并且每个页面的路径都取决于该数据本身。比如说一个用户信息系统，拥有很多用户，每个用户都有一个详情页，我们想让每个页面的URL格式为<code class="language-plaintext highlighter-rouge">users/[uid]</code>。同时，我们想要静态创建所有这些页面，从而用户可以飞速地访问这些页面。Next.js可以帮助我们很轻松地做到这一点，唯一要做的就是添加一个<code class="language-plaintext highlighter-rouge">getStaticPaths</code>函数。该函数帮助我们定义了一组需要被静态生成的页面，并返回一个数组。当我们从一个使用了动态路由的页面上导出<code class="language-plaintext highlighter-rouge">getStaticPaths</code>时，Next.js会帮助我们预渲染所有被指定的路径，通过遍历该函数返回的数组，并在每个元素上执行<code class="language-plaintext highlighter-rouge">getStaticProps</code>的方式（此处涉及到Next.js的<a href="https://nextjs.org/docs/routing/dynamic-routes">Dynamic Routes</a>相关知识）。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">UserDetail</span><span class="p">({</span><span class="nx">data</span><span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        // ...some contents
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Generates `/users/1`, `/users/2`...</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticPaths</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://userAPI/users</span><span class="dl">'</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">users</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">params</span><span class="p">:</span> <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="p">.</span><span class="nx">toString</span><span class="p">()},</span>
  <span class="p">}))</span>

  <span class="k">return</span> <span class="p">{</span><span class="nx">paths</span><span class="p">,</span> <span class="na">fallback</span><span class="p">:</span> <span class="kc">false</span><span class="p">}</span> <span class="c1">// fallback can also be true or 'blocking'</span>
<span class="p">}</span>

<span class="c1">// `getStaticPaths` requires using `getStaticProps`</span>
<span class="c1">// params is from `getStaticPaths`</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">({</span><span class="nx">params</span><span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`https://userAPI/users/</span><span class="p">${</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="k">return</span> <span class="p">{</span><span class="na">props</span><span class="p">:</span> <span class="p">{</span><span class="nx">data</span><span class="p">}}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="isr">ISR</h2>
<p>由于SSG过于静态，很多场景都不完全适用，因此我们需要一种可以支持动态数据的SSG，这时ISR出现了。Next.js在<a href="https://nextjs.org/blog/next-9-5#stable-incremental-static-regeneration">v9.5中首先提出</a>了ISR的策略，从而允许我们在整个网站构建后，以页面为单位应用静态生成，而不必重新构建整个网站。使用ISR非常简单，我们只需要给<code class="language-plaintext highlighter-rouge">getStaticProps</code>函数的返回值中添加一个<code class="language-plaintext highlighter-rouge">revalidate</code>属性。该属性定义了我们数据的最大有效期，例如在下面的例子中，我们的数据最大有效期为10秒。值得注意的是，我们的页面并不是每十秒更新一次，而是，如果数据已经过期，那么在过期后的第一次请求时，我们仍然会得到过时的页面，但是Next.js会在后台触发一次该页面的重新渲染，在新页面渲染成功后，会在缓存中替代过时页面。在这之后，再次请求将会返回新页面。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticPaths</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://userAPI/users</span><span class="dl">'</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">users</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">params</span><span class="p">:</span> <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="p">.</span><span class="nx">toString</span><span class="p">()},</span>
  <span class="p">}))</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">paths</span><span class="p">,</span>
    <span class="na">fallback</span><span class="p">:</span> <span class="dl">'</span><span class="s1">blocking</span><span class="dl">'</span> <span class="c1">// will server-render a page if doesn't exist.</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">({</span><span class="nx">params</span><span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`https://userAPI/users/</span><span class="p">${</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span><span class="nx">data</span><span class="p">},</span>
    <span class="c1">// Next.js will attempt to re-generate the page:</span>
    <span class="c1">// - When a request comes in</span>
    <span class="c1">// - At most once every 10 seconds</span>
    <span class="na">revalidate</span><span class="p">:</span> <span class="mi">10</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>其实我们这里还有一行代码和之前不同，函数<code class="language-plaintext highlighter-rouge">getStaticPaths</code>中的<code class="language-plaintext highlighter-rouge">fallback</code>被修改为了<code class="language-plaintext highlighter-rouge">blocking</code>（也可以为<code class="language-plaintext highlighter-rouge">true</code>，效果略有不同），这是Next.js中使用ISR时另一个非常有用的特性。它的意义是，当我们触发一个对不存在页面的请求时，Next.js的回退策略。详细来说，如果我们定义为<code class="language-plaintext highlighter-rouge">blocking</code>，那么当我们请求一个不存在的页面（未被静态生成），Next.js会在第一次请求时服务器渲染该页面，未来的请求则将被从缓存中提供静态文件，从而提升后续用户的访问体验。当我们的网站体量很大并且拥有很多非核心页面时，我们可以在构建时只静态预渲染核心页面，加快我们的构建速度，其他的非核心页面使用SSR在被请求时渲染并缓存。</p>

<h2 id="summary">Summary</h2>
<p>在这篇文章中我首先简略介绍了四种常见的现代Web建站技术，并且介绍了我们如何在Next.js中应用这四种策略。虽然仍然有一些内容未涉及，例如Next.js在<a href="https://nextjs.org/blog/next-12-2#on-demand-incremental-static-regeneration-stable">v12中引入</a>了On-Demand ISR，让我们可以手动清除特定页面的缓存。但是基本用法都有比较详细的介绍。下一篇中，我计划更详细地探讨每种策略的运行机制，并且比较它们的优缺点及使用场景。最后，如果有兴趣，Next.js给我们提供了一个比较四者效果的<a href="https://csr-ssr-ssg-ssr.vercel.app/">demo</a>。</p>

  </div><a class="u-url" href="/jekyll/update/2023/04/24/web-rendering-strategies.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ZZHU-ER&#39;s Tech Road</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ZZHU-ER&#39;s Tech Road</li><li><a class="u-email" href="mailto:zihao.zhu@thoughtworks.com">zihao.zhu@thoughtworks.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/zzhu-er"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">zzhu-er</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
